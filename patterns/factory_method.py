# Factory Method (Фабричный метод) - порождающий паттерн
# Определяет общий интерфейс для создания объектов. Эти интерфейсы определяют структуру, но не создают объекты.
# Создание лежит на конкретном подклассе.
########################################################################################################################
# Что решает фабричный метод:
# - Есть общий класс (Dialog), чтобы создавать разные продукты этого класса нам нужно
# обложить все методы (создание диалогов, создание кнопок, создание обработчика событий) условными операторами.
# - Если будут добавляться новые продукты, нужно будет добавлять еще операторы.
#
# Как работает фабричный метод:
# - Создается общий интерфейс продуктов (Button) и разбивается на конкретные продукты (подклассы WinButton и HTMLButton)
# - Создается фабричный класс (интерфейс Dialog) и разбивается на конкретные фабрики (подклассы WinDialog, HTMLDialog)
# - Все интерфейсы и их подклассы имеют одинаковые методы, но реализовываться они будут по разному.
# - Клиент будет получать параметры продукта, сам создаст конкретную фабрику и вызовет метод. Поскольку дальнейшая
# работа происходит с интерфейсами этому и другим методам не важно какая фабрика была создана ранее. Слабая связь.
# - Продукты будут создаваться через фабричный метод, который переопределится в подклассе конкретной фабрики,
# т.к. клиент уже создал конкретную фабрику и нам известен тип объекта фабрики.
#
# Фабричный метод позволяет создавать объекты без указания точного класса, необходимого для создания конкретного
# объекта. Это позволяет нам отделить наш код и повышает его повторное использование.
########################################################################################################################
# Применяется:
# 1. Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать код.
# 2. Когда хотим дать возможность пользователям расширять части фреймворка или библиотеки.
# 3. Когда хотим экономить системные ресурсы, повторно используя уже созданные объекты, вместо порождения новых.
########################################################################################################################
# Плюсы:
# - Код слабо связан. Большинство компонентов кода не знают о других компонентах той же кодовой базы.
# - Код легко понять и протестировать.
# - Легко добавить больше функциональности к конкретным компонентам, не затрагивая и не нарушая всю программу.
# - Поддерживает принцип Единой ответственности и Открытости / Закрытости.
########################################################################################################################
# Минусы:
# - Создание большего количества классов в конечном итоге приводит к меньшей читабельности.
########################################################################################################################
from abc import ABC, abstractmethod


class Button(ABC):
    """Абстрактный класс (базовый) для представления всех кнопок"""

    @abstractmethod
    def render(self):
        print('Abstract Button render')

    @abstractmethod
    def on_click(self):
        print('Abstract Button on-click')


class HTMLButton(Button):
    """Расширение для абстрактного класса конкретной кнопки - HTML"""

    def render(self):
        """Вернуть HTML-код кнопки"""
        print('Button render HTML')

    def on_click(self):
        """Навесить на кнопку обработчик событий браузера"""
        print('Button on-click HTML')


class WinButton(Button):
    """Расширение для абстрактного класса конкретной кнопки - Windows"""

    def render(self):
        """Отрисовать кнопку в стиле Windows"""
        print('Button render Windows')

    def on_click(self):
        """Навесить на кнопку обработчик событий Windows"""
        print('Button on-click Windows')


class Dialog(ABC):
    """
    Фабричный класс (абстрактный / базовый) для представления всех диалогов.
    Фабричный метод "create_button" - это всего лишь дополнительная роль для класса.
    В "render" - бизнес-логика для создания продуктов (Button).
    """

    def render(self):
        """
        Чтобы использовать фабричный метод "create_button", нужно убедиться в том,
        что эта бизнес-логика не зависит от конкретных классов продуктов (WinButton и HTMLButton).
        Button — это общий интерфейс кнопок, поэтому все хорошо.
        """
        button = self.create_button()
        button.on_click()
        button.render()

    @abstractmethod
    def create_button(self):
        """Фабричный метод для создания продуктов (Button)"""
        return Button()


class HTMLDialog(Dialog):
    """Расширение для абстрактного класса конкретного диалога - Фабрика Windows"""

    def create_button(self):
        return HTMLButton()


class WinDialog(Dialog):
    """Расширение для абстрактного класса конкретного диалога - Фабрика HTML"""

    def create_button(self):
        return WinButton()


class DialogResolver:
    """Приложение создаёт определённую фабрику в зависимости от конфигурации"""

    def __init__(self, dialog_type):
        if dialog_type == 'windows':
            self.dialog = WinDialog()
        elif dialog_type == 'HTML':
            self.dialog = HTMLDialog()

    def render(self):
        """
        Весь остальной код работает с фабриками (Dialog) и продуктами (Button) через интерфейсы,
        поэтому методу не важно какая фабрика была создана изначально.
        """
        self.dialog.render()


if __name__ == '__main__':
    dialog_type = input('Enter which dialog to create (windows or HTML): ')
    dialog = DialogResolver(dialog_type)
    dialog.render()

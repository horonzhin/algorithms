## Шифр Цезаря
***
В этом задании будет рассмотрен хорошо известный (хотя и не очень безопасный) метод шифрования - **шифр Цезаря**.

Идея шифра Цезаря состоит в том, чтобы выбрать целое число и сдвинуть каждую букву сообщения на это целое число.
Другими словами, предположим, что сдвиг равен *k*. Затем все экземпляры *i*-й буквы алфавита,
которые появляются в тексте, должны стать *(i+k)*-й буквой алфавита в зашифрованном тексте.

Нужно быть осторожным в случае где *i* + *k* > 26 (длина алфавита).
***
*Вот как выглядит весь алфавит сдвинутый на три точки вправо:*
```
Original:  a b c d e f g h i j k l m n o p q r s t u v w x y z
 3-shift:  d e f g h i j k l m n o p q r s t u v w x y z a b c
```
***
Используя вышеуказанный пример, мы можем быстро перевести сообщение *"happy"* в *"kdssb"*
(обратите внимание, как алфавит, сдвинутый на 3, оборачивается в конеце *x* -> *a*, *y* -> *b* и *z* -> *c*).

Мы будем обрабатывать заглавные и строчные буквы по отдельности, так что заглавные буквы всегда совпадать с заглавной буквой, а строчные буквы всегда совпадать со строчной буквой. Если заглавная буква соответствует "A", то та же самая строчная буква должна соответствовать "a". 

Знаки препинания и пробелы должны быть сохранены, а не изменены. Например, сообщение открытого текста с запятой должно содержать соответствующий зашифрованный текст с запятой в той же позиции.

|    plaintext    |  shift    |  ciphertext      |
| ----------------|-----------|------------------|
| 'abcdef'        |    2      |  'cdefgh'        |
| 'Hello, World!' |    5      |  'Mjqqt, Btwqi!' |
| ''              | any value |  ''              |

***